create table if not exists public.expense_security_quarantine (
  id bigint generated by default as identity primary key,
  expense_id uuid not null,
  group_id uuid not null,
  quarantine_reasons text[] not null,
  expense_row jsonb not null,
  split_rows jsonb not null,
  quarantined_at timestamptz not null default timezone('utc', now()),
  resolved_at timestamptz,
  resolution_note text
);

create index if not exists expense_security_quarantine_expense_id_idx
  on public.expense_security_quarantine (expense_id);

create index if not exists expense_security_quarantine_quarantined_at_idx
  on public.expense_security_quarantine (quarantined_at desc);

create temporary table _invalid_expenses on commit drop as
with split_summary as (
  select
    e.id as expense_id,
    count(es.id) as split_count,
    coalesce(sum(es.share_cents), 0)::bigint as split_sum,
    coalesce(bool_or(es.id is not null and gm_split.user_id is null), false) as has_non_member_split
  from public.expenses e
  left join public.expense_splits es on es.expense_id = e.id
  left join public.group_members gm_split
    on gm_split.group_id = e.group_id
   and gm_split.user_id = es.user_id
  group by e.id
)
select
  e.id as expense_id,
  e.group_id,
  array_remove(
    array[
      case when payer_member.user_id is null then 'payer_not_group_member' end,
      case when coalesce(ss.has_non_member_split, false) then 'split_user_not_group_member' end,
      case when coalesce(ss.split_count, 0) = 0 then 'expense_has_no_splits' end,
      case when coalesce(ss.split_sum, 0) <> e.amount_cents::bigint then 'split_sum_mismatch' end
    ],
    null
  )::text[] as quarantine_reasons
from public.expenses e
left join split_summary ss on ss.expense_id = e.id
left join public.group_members payer_member
  on payer_member.group_id = e.group_id
 and payer_member.user_id = e.paid_by
where
  payer_member.user_id is null
  or coalesce(ss.has_non_member_split, false)
  or coalesce(ss.split_count, 0) = 0
  or coalesce(ss.split_sum, 0) <> e.amount_cents::bigint;

insert into public.expense_security_quarantine (
  expense_id,
  group_id,
  quarantine_reasons,
  expense_row,
  split_rows
)
select
  e.id as expense_id,
  e.group_id,
  ie.quarantine_reasons,
  to_jsonb(e) as expense_row,
  coalesce(
    (
      select jsonb_agg(to_jsonb(es) order by es.created_at asc, es.id asc)
      from public.expense_splits es
      where es.expense_id = e.id
    ),
    '[]'::jsonb
  ) as split_rows
from _invalid_expenses ie
inner join public.expenses e on e.id = ie.expense_id;

delete from public.expenses e
using _invalid_expenses ie
where e.id = ie.expense_id;

create or replace function public.create_expense_with_splits(
  p_group_id uuid,
  p_description text,
  p_amount_cents integer,
  p_currency text,
  p_expense_date date,
  p_split_type text,
  p_entry_type text,
  p_paid_by uuid,
  p_participants jsonb
)
returns table(
  id uuid,
  group_id uuid,
  description text,
  amount_cents integer,
  currency text,
  expense_date date,
  split_type text,
  entry_type text,
  paid_by uuid,
  created_by uuid,
  created_at timestamptz,
  updated_at timestamptz
)
language plpgsql
security definer
set search_path = public
as $$
declare
  v_actor uuid;
  v_participant_count integer;
  v_split_sum bigint;
  v_percent_total numeric(8,2);
  v_expense_id uuid;
begin
  v_actor := auth.uid();

  if v_actor is null then
    raise exception 'You must be authenticated to create expenses.';
  end if;

  if p_group_id is null then
    raise exception 'Group id is required.';
  end if;

  if p_paid_by is null then
    raise exception 'Payer is required.';
  end if;

  if p_participants is null or jsonb_typeof(p_participants) <> 'array' then
    raise exception 'Participants must be a JSON array.';
  end if;

  if jsonb_array_length(p_participants) = 0 then
    raise exception 'At least one participant is required.';
  end if;

  if p_split_type not in ('equal', 'exact', 'percent') then
    raise exception 'Split type is invalid.';
  end if;

  if p_entry_type not in ('expense', 'settlement') then
    raise exception 'Entry type is invalid.';
  end if;

  if not public.is_group_member(p_group_id) then
    raise exception 'You are not a member of this group.';
  end if;

  if not exists (
    select 1
    from public.group_members gm
    where gm.group_id = p_group_id
      and gm.user_id = p_paid_by
  ) then
    raise exception 'Payer must be a member of the group.';
  end if;

  if exists (
    select 1
    from jsonb_to_recordset(p_participants) as participant(user_id uuid, share_cents integer, percent_share numeric(5,2))
    where participant.user_id is null
      or participant.share_cents is null
  ) then
    raise exception 'Each participant must include user_id and share_cents.';
  end if;

  if exists (
    select 1
    from jsonb_to_recordset(p_participants) as participant(user_id uuid, share_cents integer, percent_share numeric(5,2))
    where participant.share_cents < 0
  ) then
    raise exception 'Participant shares must be non-negative.';
  end if;

  if exists (
    select 1
    from jsonb_to_recordset(p_participants) as participant(user_id uuid, share_cents integer, percent_share numeric(5,2))
    group by participant.user_id
    having count(*) > 1
  ) then
    raise exception 'Participants must not contain duplicate users.';
  end if;

  if exists (
    select 1
    from jsonb_to_recordset(p_participants) as participant(user_id uuid, share_cents integer, percent_share numeric(5,2))
    left join public.group_members gm
      on gm.group_id = p_group_id
     and gm.user_id = participant.user_id
    where gm.user_id is null
  ) then
    raise exception 'Every participant must be a member of the group.';
  end if;

  select
    count(*)::integer,
    coalesce(sum(participant.share_cents), 0)::bigint
  into
    v_participant_count,
    v_split_sum
  from jsonb_to_recordset(p_participants) as participant(user_id uuid, share_cents integer, percent_share numeric(5,2));

  if v_split_sum <> p_amount_cents::bigint then
    raise exception 'Participant share total must exactly match amount_cents.';
  end if;

  if p_split_type = 'percent' then
    if exists (
      select 1
      from jsonb_to_recordset(p_participants) as participant(user_id uuid, share_cents integer, percent_share numeric(5,2))
      where participant.percent_share is null
    ) then
      raise exception 'Percent split requires percent_share for every participant.';
    end if;

    select
      coalesce(sum(participant.percent_share), 0)::numeric(8,2)
    into v_percent_total
    from jsonb_to_recordset(p_participants) as participant(user_id uuid, share_cents integer, percent_share numeric(5,2));

    if abs(v_percent_total - 100) > 0.01 then
      raise exception 'Percent shares must sum to 100.';
    end if;
  elsif exists (
    select 1
    from jsonb_to_recordset(p_participants) as participant(user_id uuid, share_cents integer, percent_share numeric(5,2))
    where participant.percent_share is not null
  ) then
    raise exception 'percent_share is only valid for percent split type.';
  end if;

  if p_entry_type = 'expense' and v_participant_count < 2 then
    raise exception 'Expense entries require at least two participants.';
  end if;

  if p_entry_type = 'settlement' then
    if p_split_type <> 'exact' then
      raise exception 'Settlement entries must use exact split type.';
    end if;

    if v_participant_count <> 1 then
      raise exception 'Settlement entries must have exactly one participant.';
    end if;

    if exists (
      select 1
      from jsonb_to_recordset(p_participants) as participant(user_id uuid, share_cents integer, percent_share numeric(5,2))
      where participant.user_id = p_paid_by
    ) then
      raise exception 'Settlement participant cannot be the payer.';
    end if;
  end if;

  insert into public.expenses (
    group_id,
    description,
    amount_cents,
    currency,
    expense_date,
    split_type,
    entry_type,
    paid_by,
    created_by
  )
  values (
    p_group_id,
    trim(p_description),
    p_amount_cents,
    upper(trim(p_currency)),
    p_expense_date,
    p_split_type,
    p_entry_type,
    p_paid_by,
    v_actor
  )
  returning expenses.id into v_expense_id;

  insert into public.expense_splits (
    expense_id,
    user_id,
    share_cents,
    percent_share
  )
  select
    v_expense_id,
    participant.user_id,
    participant.share_cents,
    participant.percent_share
  from jsonb_to_recordset(p_participants) as participant(user_id uuid, share_cents integer, percent_share numeric(5,2));

  return query
    select
      e.id,
      e.group_id,
      e.description,
      e.amount_cents,
      e.currency,
      e.expense_date,
      e.split_type,
      e.entry_type,
      e.paid_by,
      e.created_by,
      e.created_at,
      e.updated_at
    from public.expenses e
    where e.id = v_expense_id;
end;
$$;

create or replace function public.update_expense_with_splits(
  p_expense_id uuid,
  p_description text,
  p_amount_cents integer,
  p_currency text,
  p_expense_date date,
  p_split_type text,
  p_paid_by uuid,
  p_participants jsonb
)
returns table(
  id uuid,
  group_id uuid,
  description text,
  amount_cents integer,
  currency text,
  expense_date date,
  split_type text,
  entry_type text,
  paid_by uuid,
  created_by uuid,
  created_at timestamptz,
  updated_at timestamptz
)
language plpgsql
security definer
set search_path = public
as $$
declare
  v_actor uuid;
  v_group_id uuid;
  v_created_by uuid;
  v_entry_type text;
  v_participant_count integer;
  v_split_sum bigint;
  v_percent_total numeric(8,2);
begin
  v_actor := auth.uid();

  if v_actor is null then
    raise exception 'You must be authenticated to update expenses.';
  end if;

  if p_expense_id is null then
    raise exception 'Expense id is required.';
  end if;

  if p_paid_by is null then
    raise exception 'Payer is required.';
  end if;

  if p_participants is null or jsonb_typeof(p_participants) <> 'array' then
    raise exception 'Participants must be a JSON array.';
  end if;

  if jsonb_array_length(p_participants) = 0 then
    raise exception 'At least one participant is required.';
  end if;

  if p_split_type not in ('equal', 'exact', 'percent') then
    raise exception 'Split type is invalid.';
  end if;

  select
    e.group_id,
    e.created_by,
    e.entry_type
  into
    v_group_id,
    v_created_by,
    v_entry_type
  from public.expenses e
  where e.id = p_expense_id
  for update;

  if not found then
    raise exception 'Expense not found.';
  end if;

  if v_created_by <> v_actor then
    raise exception 'Only the expense creator can update this expense.';
  end if;

  if v_entry_type = 'settlement' then
    raise exception 'Settlement entries cannot be edited.';
  end if;

  if not public.is_group_member(v_group_id) then
    raise exception 'You are not a member of this group.';
  end if;

  if not exists (
    select 1
    from public.group_members gm
    where gm.group_id = v_group_id
      and gm.user_id = p_paid_by
  ) then
    raise exception 'Payer must be a member of the group.';
  end if;

  if exists (
    select 1
    from jsonb_to_recordset(p_participants) as participant(user_id uuid, share_cents integer, percent_share numeric(5,2))
    where participant.user_id is null
      or participant.share_cents is null
  ) then
    raise exception 'Each participant must include user_id and share_cents.';
  end if;

  if exists (
    select 1
    from jsonb_to_recordset(p_participants) as participant(user_id uuid, share_cents integer, percent_share numeric(5,2))
    where participant.share_cents < 0
  ) then
    raise exception 'Participant shares must be non-negative.';
  end if;

  if exists (
    select 1
    from jsonb_to_recordset(p_participants) as participant(user_id uuid, share_cents integer, percent_share numeric(5,2))
    group by participant.user_id
    having count(*) > 1
  ) then
    raise exception 'Participants must not contain duplicate users.';
  end if;

  if exists (
    select 1
    from jsonb_to_recordset(p_participants) as participant(user_id uuid, share_cents integer, percent_share numeric(5,2))
    left join public.group_members gm
      on gm.group_id = v_group_id
     and gm.user_id = participant.user_id
    where gm.user_id is null
  ) then
    raise exception 'Every participant must be a member of the group.';
  end if;

  select
    count(*)::integer,
    coalesce(sum(participant.share_cents), 0)::bigint
  into
    v_participant_count,
    v_split_sum
  from jsonb_to_recordset(p_participants) as participant(user_id uuid, share_cents integer, percent_share numeric(5,2));

  if v_split_sum <> p_amount_cents::bigint then
    raise exception 'Participant share total must exactly match amount_cents.';
  end if;

  if p_split_type = 'percent' then
    if exists (
      select 1
      from jsonb_to_recordset(p_participants) as participant(user_id uuid, share_cents integer, percent_share numeric(5,2))
      where participant.percent_share is null
    ) then
      raise exception 'Percent split requires percent_share for every participant.';
    end if;

    select
      coalesce(sum(participant.percent_share), 0)::numeric(8,2)
    into v_percent_total
    from jsonb_to_recordset(p_participants) as participant(user_id uuid, share_cents integer, percent_share numeric(5,2));

    if abs(v_percent_total - 100) > 0.01 then
      raise exception 'Percent shares must sum to 100.';
    end if;
  elsif exists (
    select 1
    from jsonb_to_recordset(p_participants) as participant(user_id uuid, share_cents integer, percent_share numeric(5,2))
    where participant.percent_share is not null
  ) then
    raise exception 'percent_share is only valid for percent split type.';
  end if;

  if v_entry_type = 'expense' and v_participant_count < 2 then
    raise exception 'Expense entries require at least two participants.';
  end if;

  update public.expenses
  set
    description = trim(p_description),
    amount_cents = p_amount_cents,
    currency = upper(trim(p_currency)),
    expense_date = p_expense_date,
    split_type = p_split_type,
    paid_by = p_paid_by
  where id = p_expense_id;

  delete from public.expense_splits es
  where es.expense_id = p_expense_id;

  insert into public.expense_splits (
    expense_id,
    user_id,
    share_cents,
    percent_share
  )
  select
    p_expense_id,
    participant.user_id,
    participant.share_cents,
    participant.percent_share
  from jsonb_to_recordset(p_participants) as participant(user_id uuid, share_cents integer, percent_share numeric(5,2));

  return query
    select
      e.id,
      e.group_id,
      e.description,
      e.amount_cents,
      e.currency,
      e.expense_date,
      e.split_type,
      e.entry_type,
      e.paid_by,
      e.created_by,
      e.created_at,
      e.updated_at
    from public.expenses e
    where e.id = p_expense_id;
end;
$$;

revoke all on function public.create_expense_with_splits(
  uuid,
  text,
  integer,
  text,
  date,
  text,
  text,
  uuid,
  jsonb
) from public, anon;

grant execute on function public.create_expense_with_splits(
  uuid,
  text,
  integer,
  text,
  date,
  text,
  text,
  uuid,
  jsonb
) to authenticated;

revoke all on function public.update_expense_with_splits(
  uuid,
  text,
  integer,
  text,
  date,
  text,
  uuid,
  jsonb
) from public, anon;

grant execute on function public.update_expense_with_splits(
  uuid,
  text,
  integer,
  text,
  date,
  text,
  uuid,
  jsonb
) to authenticated;

notify pgrst, 'reload schema';
