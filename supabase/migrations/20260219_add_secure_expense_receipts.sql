alter table public.expenses
  add column if not exists receipt_bucket text,
  add column if not exists receipt_object_path text,
  add column if not exists receipt_mime_type text,
  add column if not exists receipt_size_bytes integer,
  add column if not exists receipt_uploaded_by uuid references auth.users(id) on delete cascade,
  add column if not exists receipt_uploaded_at timestamptz;

alter table public.expenses
  drop constraint if exists expenses_receipt_all_or_none;
alter table public.expenses
  add constraint expenses_receipt_all_or_none
  check (
    (
      receipt_bucket is null
      and receipt_object_path is null
      and receipt_mime_type is null
      and receipt_size_bytes is null
      and receipt_uploaded_by is null
      and receipt_uploaded_at is null
    )
    or
    (
      receipt_bucket is not null
      and receipt_object_path is not null
      and receipt_mime_type is not null
      and receipt_size_bytes is not null
      and receipt_uploaded_by is not null
      and receipt_uploaded_at is not null
    )
  );

alter table public.expenses
  drop constraint if exists expenses_receipt_bucket_check;
alter table public.expenses
  add constraint expenses_receipt_bucket_check
  check (
    receipt_bucket is null
    or receipt_bucket = 'expense-receipts'
  );

alter table public.expenses
  drop constraint if exists expenses_receipt_mime_type_check;
alter table public.expenses
  add constraint expenses_receipt_mime_type_check
  check (
    receipt_mime_type is null
    or lower(receipt_mime_type) in (
      'image/jpeg',
      'image/png',
      'image/webp',
      'image/heic',
      'image/heif'
    )
  );

alter table public.expenses
  drop constraint if exists expenses_receipt_size_bytes_check;
alter table public.expenses
  add constraint expenses_receipt_size_bytes_check
  check (
    receipt_size_bytes is null
    or (receipt_size_bytes > 0 and receipt_size_bytes <= 5000000)
  );

alter table public.expenses
  drop constraint if exists expenses_receipt_uploaded_by_creator_check;
alter table public.expenses
  add constraint expenses_receipt_uploaded_by_creator_check
  check (
    receipt_uploaded_by is null
    or receipt_uploaded_by = created_by
  );

create unique index if not exists expenses_receipt_object_path_unique_idx
  on public.expenses (receipt_object_path)
  where receipt_object_path is not null;

create table if not exists public.expense_receipt_cleanup_queue (
  id bigint generated by default as identity primary key,
  bucket_id text not null,
  object_path text not null,
  reason text not null,
  status text not null default 'pending' check (status in ('pending', 'success', 'error')),
  error text,
  created_at timestamptz not null default timezone('utc', now()),
  processed_at timestamptz
);

create unique index if not exists expense_receipt_cleanup_queue_pending_unique_idx
  on public.expense_receipt_cleanup_queue (bucket_id, object_path)
  where status = 'pending';

create index if not exists expense_receipt_cleanup_queue_created_at_idx
  on public.expense_receipt_cleanup_queue (created_at desc);

alter table public.expense_receipt_cleanup_queue enable row level security;

create or replace function public.enqueue_expense_receipt_cleanup()
returns trigger
language plpgsql
security definer
set search_path = public
as $$
declare
  v_bucket text;
  v_path text;
  v_reason text;
begin
  if tg_op = 'UPDATE' then
    v_bucket := old.receipt_bucket;
    v_path := old.receipt_object_path;

    if v_path is null then
      return new;
    end if;

    v_reason := case
      when new.receipt_object_path is null then 'receipt_cleared'
      else 'receipt_replaced'
    end;

  elsif tg_op = 'DELETE' then
    v_bucket := old.receipt_bucket;
    v_path := old.receipt_object_path;

    if v_path is null then
      return old;
    end if;

    v_reason := 'expense_deleted';
  else
    return coalesce(new, old);
  end if;

  insert into public.expense_receipt_cleanup_queue (
    bucket_id,
    object_path,
    reason
  )
  values (
    v_bucket,
    v_path,
    v_reason
  )
  on conflict (bucket_id, object_path)
  where status = 'pending'
  do nothing;

  if tg_op = 'DELETE' then
    return old;
  end if;

  return new;
end;
$$;

drop trigger if exists enqueue_expense_receipt_cleanup_update on public.expenses;
create trigger enqueue_expense_receipt_cleanup_update
  after update of receipt_object_path
  on public.expenses
  for each row
  when (old.receipt_object_path is distinct from new.receipt_object_path)
  execute function public.enqueue_expense_receipt_cleanup();

drop trigger if exists enqueue_expense_receipt_cleanup_delete on public.expenses;
create trigger enqueue_expense_receipt_cleanup_delete
  after delete
  on public.expenses
  for each row
  execute function public.enqueue_expense_receipt_cleanup();

insert into storage.buckets (
  id,
  name,
  public,
  file_size_limit,
  allowed_mime_types
)
values (
  'expense-receipts',
  'expense-receipts',
  false,
  5000000,
  array[
    'image/jpeg',
    'image/png',
    'image/webp',
    'image/heic',
    'image/heif'
  ]::text[]
)
on conflict (id)
do update set
  public = excluded.public,
  file_size_limit = excluded.file_size_limit,
  allowed_mime_types = excluded.allowed_mime_types;

drop policy if exists "Expense receipt creators can upload" on storage.objects;
create policy "Expense receipt creators can upload"
  on storage.objects
  for insert
  to authenticated
  with check (
    bucket_id = 'expense-receipts'
    and array_length(storage.foldername(name), 1) = 3
    and (storage.foldername(name))[1] = 'expenses'
    and nullif((storage.foldername(name))[2], '') is not null
    and (storage.foldername(name))[3] = auth.uid()::text
    and exists (
      select 1
      from public.expenses e
      where e.id::text = (storage.foldername(name))[2]
        and e.created_by = auth.uid()
    )
  );

drop policy if exists "Group members can read linked expense receipts" on storage.objects;
create policy "Group members can read linked expense receipts"
  on storage.objects
  for select
  to authenticated
  using (
    bucket_id = 'expense-receipts'
    and exists (
      select 1
      from public.expenses e
      where e.receipt_bucket = 'expense-receipts'
        and e.receipt_object_path = name
        and public.is_group_member(e.group_id)
    )
  );

create or replace function public.attach_expense_receipt(
  p_expense_id uuid,
  p_bucket text,
  p_object_path text,
  p_mime_type text,
  p_size_bytes integer
)
returns table(
  expense_id uuid,
  receipt_bucket text,
  receipt_object_path text,
  receipt_mime_type text,
  receipt_size_bytes integer,
  receipt_uploaded_by uuid,
  receipt_uploaded_at timestamptz
)
language plpgsql
security definer
set search_path = public, storage
as $$
declare
  v_actor uuid;
  v_group_id uuid;
  v_created_by uuid;
  v_path_parts text[];
  v_extension text;
  v_object_owner uuid;
  v_object_metadata jsonb;
  v_object_mime text;
  v_object_size bigint;
begin
  v_actor := auth.uid();

  if v_actor is null then
    raise exception 'You must be authenticated to attach receipts.';
  end if;

  if p_expense_id is null then
    raise exception 'Expense id is required.';
  end if;

  if p_bucket is null or trim(p_bucket) = '' then
    raise exception 'Receipt bucket is required.';
  end if;

  if p_bucket <> 'expense-receipts' then
    raise exception 'Receipt bucket is invalid.';
  end if;

  if p_object_path is null or trim(p_object_path) = '' then
    raise exception 'Receipt object path is required.';
  end if;

  if p_size_bytes is null or p_size_bytes <= 0 or p_size_bytes > 5000000 then
    raise exception 'Receipt size is invalid.';
  end if;

  if p_mime_type is null or lower(trim(p_mime_type)) not in (
    'image/jpeg',
    'image/png',
    'image/webp',
    'image/heic',
    'image/heif'
  ) then
    raise exception 'Receipt mime type is invalid.';
  end if;

  select
    e.group_id,
    e.created_by
  into
    v_group_id,
    v_created_by
  from public.expenses e
  where e.id = p_expense_id
  for update;

  if not found then
    raise exception 'Expense not found.';
  end if;

  if not public.is_group_member(v_group_id) then
    raise exception 'You are not a member of this group.';
  end if;

  if v_created_by <> v_actor then
    raise exception 'Only the expense creator can attach a receipt.';
  end if;

  v_path_parts := regexp_split_to_array(p_object_path, '/');

  if array_length(v_path_parts, 1) <> 4 then
    raise exception 'Receipt object path format is invalid.';
  end if;

  if (
    v_path_parts[1] <> 'expenses'
    or v_path_parts[2] <> p_expense_id::text
    or v_path_parts[3] <> v_actor::text
    or nullif(v_path_parts[4], '') is null
  ) then
    raise exception 'Receipt object path is not authorized for this expense.';
  end if;

  v_extension := lower(coalesce(storage.extension(p_object_path), ''));
  if v_extension not in ('jpg', 'jpeg', 'png', 'webp', 'heic', 'heif') then
    raise exception 'Receipt file extension is invalid.';
  end if;

  select
    o.owner,
    o.metadata
  into
    v_object_owner,
    v_object_metadata
  from storage.objects o
  where o.bucket_id = p_bucket
    and o.name = p_object_path
  limit 1;

  if not found then
    raise exception 'Receipt object does not exist.';
  end if;

  if v_object_owner is not null and v_object_owner <> v_actor then
    raise exception 'Receipt object owner does not match actor.';
  end if;

  v_object_mime := lower(
    coalesce(
      v_object_metadata ->> 'mimetype',
      v_object_metadata ->> 'mimeType',
      v_object_metadata ->> 'contentType',
      ''
    )
  );

  if v_object_mime <> '' and v_object_mime not in (
    'image/jpeg',
    'image/png',
    'image/webp',
    'image/heic',
    'image/heif'
  ) then
    raise exception 'Stored object mime type is not allowed.';
  end if;

  if v_object_mime <> '' and v_object_mime <> lower(trim(p_mime_type)) then
    raise exception 'Stored object mime type does not match provided mime type.';
  end if;

  begin
    v_object_size := nullif(v_object_metadata ->> 'size', '')::bigint;
  exception
    when others then
      v_object_size := null;
  end;

  if v_object_size is not null and (v_object_size <= 0 or v_object_size > 5000000) then
    raise exception 'Stored object size is invalid.';
  end if;

  if v_object_size is not null and v_object_size <> p_size_bytes::bigint then
    raise exception 'Stored object size does not match provided size.';
  end if;

  update public.expenses
  set
    receipt_bucket = p_bucket,
    receipt_object_path = p_object_path,
    receipt_mime_type = lower(trim(p_mime_type)),
    receipt_size_bytes = p_size_bytes,
    receipt_uploaded_by = v_actor,
    receipt_uploaded_at = timezone('utc', now())
  where id = p_expense_id;

  return query
    select
      e.id as expense_id,
      e.receipt_bucket,
      e.receipt_object_path,
      e.receipt_mime_type,
      e.receipt_size_bytes,
      e.receipt_uploaded_by,
      e.receipt_uploaded_at
    from public.expenses e
    where e.id = p_expense_id;
end;
$$;

create or replace function public.clear_expense_receipt(
  p_expense_id uuid
)
returns table(
  expense_id uuid,
  receipt_bucket text,
  receipt_object_path text,
  receipt_mime_type text,
  receipt_size_bytes integer,
  receipt_uploaded_by uuid,
  receipt_uploaded_at timestamptz
)
language plpgsql
security definer
set search_path = public
as $$
declare
  v_actor uuid;
  v_group_id uuid;
  v_created_by uuid;
begin
  v_actor := auth.uid();

  if v_actor is null then
    raise exception 'You must be authenticated to clear receipts.';
  end if;

  if p_expense_id is null then
    raise exception 'Expense id is required.';
  end if;

  select
    e.group_id,
    e.created_by
  into
    v_group_id,
    v_created_by
  from public.expenses e
  where e.id = p_expense_id
  for update;

  if not found then
    raise exception 'Expense not found.';
  end if;

  if not public.is_group_member(v_group_id) then
    raise exception 'You are not a member of this group.';
  end if;

  if v_created_by <> v_actor then
    raise exception 'Only the expense creator can clear a receipt.';
  end if;

  update public.expenses
  set
    receipt_bucket = null,
    receipt_object_path = null,
    receipt_mime_type = null,
    receipt_size_bytes = null,
    receipt_uploaded_by = null,
    receipt_uploaded_at = null
  where id = p_expense_id;

  return query
    select
      e.id as expense_id,
      e.receipt_bucket,
      e.receipt_object_path,
      e.receipt_mime_type,
      e.receipt_size_bytes,
      e.receipt_uploaded_by,
      e.receipt_uploaded_at
    from public.expenses e
    where e.id = p_expense_id;
end;
$$;

revoke all on function public.attach_expense_receipt(uuid, text, text, text, integer)
  from public, anon;
grant execute on function public.attach_expense_receipt(uuid, text, text, text, integer)
  to authenticated;

revoke all on function public.clear_expense_receipt(uuid)
  from public, anon;
grant execute on function public.clear_expense_receipt(uuid)
  to authenticated;

drop function if exists public.get_friend_activity(uuid);

create function public.get_friend_activity(p_friend_id uuid)
returns table(
  expense_id uuid,
  description text,
  amount_cents integer,
  expense_date date,
  group_id uuid,
  group_name text,
  group_emoji text,
  entry_type text,
  paid_by_me boolean,
  my_share integer,
  friend_share integer,
  receipt_attached boolean
)
language sql
security definer
set search_path = public
as $$
  with shared_groups as (
    select gm1.group_id
    from public.group_members gm1
    inner join public.group_members gm2 on gm2.group_id = gm1.group_id
    where gm1.user_id = auth.uid()
      and gm2.user_id = p_friend_id
  )
  select
    e.id as expense_id,
    e.description,
    e.amount_cents,
    e.expense_date,
    e.group_id,
    g.name as group_name,
    g.emoji as group_emoji,
    e.entry_type,
    (e.paid_by = auth.uid()) as paid_by_me,
    coalesce(my_split.share_cents, 0) as my_share,
    coalesce(friend_split.share_cents, 0) as friend_share,
    (e.receipt_object_path is not null) as receipt_attached
  from public.expenses e
  inner join shared_groups sg on sg.group_id = e.group_id
  inner join public.groups g on g.id = e.group_id
  left join public.expense_splits my_split
    on my_split.expense_id = e.id and my_split.user_id = auth.uid()
  left join public.expense_splits friend_split
    on friend_split.expense_id = e.id and friend_split.user_id = p_friend_id
  where (
    (e.paid_by = auth.uid() and friend_split.id is not null)
    or
    (e.paid_by = p_friend_id and my_split.id is not null)
  )
  order by e.expense_date desc, e.created_at desc, e.id desc
  limit 50;
$$;

revoke all on function public.get_friend_activity(uuid) from public, anon;
grant execute on function public.get_friend_activity(uuid) to authenticated;

drop function if exists public.get_home_recent_activity(integer);

create function public.get_home_recent_activity(p_limit integer default 10)
returns table(
  expense_id uuid,
  group_id uuid,
  group_name text,
  group_emoji text,
  description text,
  entry_type text,
  expense_date date,
  created_at timestamptz,
  net_cents bigint,
  direction text,
  receipt_attached boolean
)
language sql
security definer
set search_path = public
as $$
  with my_groups as (
    select distinct gm.group_id
    from public.group_members gm
    where gm.user_id = auth.uid()
  ),
  expense_contributions as (
    select
      e.id as expense_id,
      e.group_id,
      e.description,
      e.entry_type,
      e.expense_date,
      e.created_at,
      (e.receipt_object_path is not null) as receipt_attached,
      case
        when e.paid_by = auth.uid() then
          coalesce(sum(case when es.user_id <> auth.uid() then es.share_cents else 0 end), 0)::bigint
        else
          -coalesce(max(case when es.user_id = auth.uid() then es.share_cents else null end), 0)::bigint
      end as my_net_cents
    from public.expenses e
    inner join my_groups mg on mg.group_id = e.group_id
    inner join public.expense_splits es on es.expense_id = e.id
    where e.paid_by = auth.uid()
      or exists (
        select 1
        from public.expense_splits me
        where me.expense_id = e.id
          and me.user_id = auth.uid()
      )
    group by e.id, e.group_id, e.description, e.entry_type, e.expense_date, e.created_at, e.paid_by
  )
  select
    ec.expense_id,
    ec.group_id,
    g.name as group_name,
    g.emoji as group_emoji,
    ec.description,
    ec.entry_type,
    ec.expense_date,
    ec.created_at,
    ec.my_net_cents as net_cents,
    case
      when ec.my_net_cents > 0 then 'you_are_owed'
      else 'you_owe'
    end as direction,
    ec.receipt_attached
  from expense_contributions ec
  inner join public.groups g on g.id = ec.group_id
  where ec.my_net_cents <> 0
    and g.group_kind = 'standard'
  order by ec.expense_date desc, ec.created_at desc, ec.expense_id desc
  limit greatest(1, least(coalesce(p_limit, 10), 50));
$$;

revoke all on function public.get_home_recent_activity(integer) from public, anon;
grant execute on function public.get_home_recent_activity(integer) to authenticated;

notify pgrst, 'reload schema';
